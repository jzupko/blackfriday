package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"time"
)

const (
	/* Expected format:
		[
			{
				"emoji": "ðŸ˜€",
				"description": "grinning face",
				"category": "Smileys & Emotion",
				"aliases": [
					"grinning"
				],
				"tags": [
					"smile",
					"happy"
				],
				"unicode_version": "6.1",
				"ios_version": "6.0"
			},
			...
		*/
	remoteFile = `https://raw.githubusercontent.com/github/gemoji/master/db/emoji.json`
	requestTimeout = 5 * time.Second
)

type emojiEntry struct {
	Emoji string       `json:"emoji"`
	Description string `json:"description"`
	Category string    `json:"category"`
	Aliases []string   `json:"aliases"`
	Tags []string      `json:"tags"`
}

type emojiData []emojiEntry

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func must(n int, err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func getEmojiBaseFilename(codepoint string) string {
	var filename string
	for i, r := range codepoint {
		if i > 0 {
			// TODO(jzupko): Need to figure out why this is - looks like twitter
			// excludes this part of the code point.
			if 0xfe0f != int64(r) {
				filename += "-" + strconv.FormatInt(int64(r), 16)
			}
		} else {
			filename = strconv.FormatInt(int64(r), 16)
		}
	}

	return filename
}

var outputFilename string

func generatorEmojiGo(data emojiData) {
	f, err := os.Create(outputFilename)
	check(err)
	defer f.Close()

	w := bufio.NewWriter(f)
	defer w.Flush()

	must(fmt.Fprintln(w, "package blackfriday"))
	must(fmt.Fprintln(w, ""))
	must(fmt.Fprintln(w, "// Autogenerated file. Do not modify."))
	must(fmt.Fprintln(w, "// Generated from: " + remoteFile))
	must(fmt.Fprintln(w, "var markdownEmojiLookup = map[string]string{"))

	for _, e := range data {
		filename := getEmojiBaseFilename(e.Emoji)
		for _, alias := range e.Aliases {
			must(fmt.Fprintf(w, "\t\"%s\": \"%s\",\n", alias, filename))
		}
	}

	must(fmt.Fprintln(w, "}"))
}

func main() {
	flag.StringVar(&outputFilename, "o", "", "output path for the generated go")
	flag.Parse()

	if "" == outputFilename {
		log.Fatal("Usage: emoji_generator -o <path_to_output.go>")
	}

	// Normalize.
	if !filepath.IsAbs(outputFilename) {
		exePath, err := os.Getwd()
		check(err)
		outputFilename = filepath.Clean(filepath.Join(filepath.Dir(exePath), outputFilename))
	}

	client := http.Client{
		Timeout: requestTimeout,
	}

	req, err := http.NewRequest(http.MethodGet, remoteFile, nil)
	check(err)

	// So we don't get rejected.
	req.Header.Set("User-Agent", "Emoji-Generator")

	res, err := client.Do(req)
	check(err)
	defer res.Body.Close()

	body, err := ioutil.ReadAll(res.Body)
	check(err)

	var data emojiData
	check(json.Unmarshal(body, &data))

	fmt.Println("Writing output to:", outputFilename)
	generatorEmojiGo(data)
}